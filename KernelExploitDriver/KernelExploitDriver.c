#include<ntddk.h>

#define ARBITRARY_OVERWRITE_CONTROL_CODE			CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_NEITHER, FILE_ANY_ACCESS)
#define NULL_POINTER_DEREFERENCE_CONTROL_CODE		CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_NEITHER, FILE_ANY_ACCESS)
#define USE_AFTER_FREE_CONTROL_CODE					CTL_CODE(FILE_DEVICE_UNKNOWN, 0x802, METHOD_NEITHER, FILE_ANY_ACCESS)
#define BUFFER_SIZE									512

typedef void(*FunctionPointer)();

typedef struct _WRITE_WHAT_WHERE
{
	PULONG_PTR pulptrWhatAddress;
	PULONG_PTR pulptrWhereAddress;
}WRITE_WHAT_WHERE, *PWRITE_WHAT_WHERE;

VOID NullPointerDereferenceObjectCallback()
{
	return;
}

typedef struct _NULL_POINTER_DEREFERENCE
{
	ULONG_PTR ulptrValue;
	FunctionPointer Callback;
}NULL_POINTER_DEREFERENCE, *PNULL_POINTER_DEREFERENCE;

NTSTATUS NTAPI ArbitaryOverWriteHandler(
	_In_ PIRP pIrp,
	_In_ PIO_STACK_LOCATION pStackLocation
	)
{
	NTSTATUS status = STATUS_SUCCESS;
	PWRITE_WHAT_WHERE pvUserBuffer = NULL;
	PULONG_PTR What = NULL;
	PULONG_PTR Where = NULL;

	UNREFERENCED_PARAMETER(pIrp);

	pvUserBuffer = (PWRITE_WHAT_WHERE)pStackLocation->Parameters.DeviceIoControl.Type3InputBuffer;

	if (NULL == pvUserBuffer)
	{
		goto _RET;
	}

	__try
	{
		ProbeForRead(pvUserBuffer, sizeof(WRITE_WHAT_WHERE), (ULONG)__alignof(WRITE_WHAT_WHERE));
		What = ((PWRITE_WHAT_WHERE)pvUserBuffer)->pulptrWhatAddress;
		Where = ((PWRITE_WHAT_WHERE)pvUserBuffer)->pulptrWhereAddress;

		// 해당 메모리 주소가 유저모드 메모리 주소인지 검사를 하지 않으면 커널 메모리 주소를 덮어버린다.
		//ProbeForRead((PVOID)Where, sizeof(PULONG_PTR), (ULONG)__alignof(PULONG_PTR));
		//ProbeForRead((PVOID)What, sizeof(PULONG_PTR), (ULONG)__alignof(PULONG_PTR));
		*(Where) = *(What);
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		status = GetExceptionCode();
	}

_RET:
	return status;
}

NTSTATUS NTAPI NullPointerDereferenceHandler(
	_In_ PIRP pIrp,
	_In_ PIO_STACK_LOCATION pStackLocation
	)
{
	NTSTATUS status = STATUS_SUCCESS;
	PWRITE_WHAT_WHERE pvUserBuffer = NULL;
	ULONG_PTR ulptrUserValue = 0;
	ULONG MagicValue = 0xBAD0B0B0;
	PNULL_POINTER_DEREFERENCE NullPointerDereference = NULL;

	UNREFERENCED_PARAMETER(pIrp);

	pvUserBuffer = (PWRITE_WHAT_WHERE)pStackLocation->Parameters.DeviceIoControl.Type3InputBuffer;

	if (NULL == pvUserBuffer)
	{
		goto _RET;
	}

	__try
	{
		ProbeForRead(pvUserBuffer, sizeof(NULL_POINTER_DEREFERENCE), (ULONG)__alignof(NULL_POINTER_DEREFERENCE));
		NullPointerDereference = (PNULL_POINTER_DEREFERENCE)ExAllocatePool(NonPagedPool, sizeof(NULL_POINTER_DEREFERENCE));

		if (NULL != NullPointerDereference)
		{
			ulptrUserValue = *(PULONG_PTR)pvUserBuffer;

			if (ulptrUserValue == MagicValue)
			{
				NullPointerDereference->ulptrValue = ulptrUserValue;
				NullPointerDereference->Callback = &NullPointerDereferenceObjectCallback;
			}
			else
			{
				if (NULL != NullPointerDereference)
				{
					ExFreePool(NullPointerDereference);
					NullPointerDereference = NULL;
				}
			}

			//if (NullPointerDereference) 
			//{
			//	NullPointerDereference->Callback();
			//}

			NullPointerDereference->Callback();
		}
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		status = GetExceptionCode();
	}

_RET:
	return status;
}

NTSTATUS NTAPI UserAfterFreeHandler(
	_In_ PIRP pIrp,
	_In_ PIO_STACK_LOCATION pStackLocation
	)
{
	NTSTATUS status = STATUS_SUCCESS;
	PVOID pvUserBuffer = NULL;

	UNREFERENCED_PARAMETER(pIrp);

	pvUserBuffer = (PVOID)pStackLocation->Parameters.DeviceIoControl.Type3InputBuffer;

	if (NULL == pvUserBuffer)
	{
		goto _RET;
	}

	__try
	{

	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		status = GetExceptionCode();
	}

_RET:
	return status;
}

NTSTATUS NTAPI DeviceIOControlHandler(
	_In_ PDEVICE_OBJECT pDeviceObject,
	_In_ PIRP pIrp
	)
{
	NTSTATUS status = STATUS_SUCCESS;
	PIO_STACK_LOCATION pStackLocation = NULL;
	ULONG ulControlCode = 0;

	UNREFERENCED_PARAMETER(pDeviceObject);

	pStackLocation = IoGetCurrentIrpStackLocation(pIrp);

	if (NULL == pStackLocation)
	{
		goto _RET;
	}

	ulControlCode = pStackLocation->Parameters.DeviceIoControl.IoControlCode;

	switch (ulControlCode)
	{
	case ARBITRARY_OVERWRITE_CONTROL_CODE:
		status = ArbitaryOverWriteHandler(pIrp, pStackLocation);
		break;
	case NULL_POINTER_DEREFERENCE_CONTROL_CODE:
		status = NullPointerDereferenceHandler(pIrp, pStackLocation);
		break;
	case USE_AFTER_FREE_CONTROL_CODE:
		status = UserAfterFreeHandler(pIrp, pStackLocation);
	default:
		break;
	}	

	pIrp->IoStatus.Status = status;
	pIrp->IoStatus.Information = 0;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);

_RET:
	return status;
}

NTSTATUS NTAPI DefaultHandler(
	_In_ PDEVICE_OBJECT pDeviceObject,
	_In_ PIRP pIrp
	)
{
	UNREFERENCED_PARAMETER(pDeviceObject);

	pIrp->IoStatus.Information = 0;
	pIrp->IoStatus.Status = STATUS_NOT_SUPPORTED;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	return STATUS_NOT_SUPPORTED;
}

NTSTATUS CreateCloseHandler(
	_In_ PDEVICE_OBJECT pDeviceObject,
	_In_ PIRP pIrp
	)
{
	UNREFERENCED_PARAMETER(pDeviceObject);

	pIrp->IoStatus.Information = 0;
	pIrp->IoStatus.Status = STATUS_SUCCESS;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}

VOID DriverUnload(
	_In_ PDRIVER_OBJECT pDriverObject
	)
{
	UNICODE_STRING uniDosDeviceName = { 0, };

	UNREFERENCED_PARAMETER(pDriverObject);

	RtlInitUnicodeString(&uniDosDeviceName, L"\\DosDevices\\KernelExploitDriver");
	IoDeleteSymbolicLink(&uniDosDeviceName);
	IoDeleteDevice(pDriverObject->DeviceObject);

	return;
}

NTSTATUS DriverEntry(
	_In_ PDRIVER_OBJECT pDriverObject,
	_In_ PUNICODE_STRING puniRegistryPath
	)
{
	NTSTATUS status = STATUS_SUCCESS;
	UNICODE_STRING uniDeviceName = { 0, };
	UNICODE_STRING uniDosDeviceName = { 0, };
	PDEVICE_OBJECT pDeviceObject = NULL;
	ULONG ulIndex = 0;

	UNREFERENCED_PARAMETER(puniRegistryPath);

	for (ulIndex = 0; ulIndex < IRP_MJ_MAXIMUM_FUNCTION; ++ulIndex)
	{
		pDriverObject->MajorFunction[ulIndex] = DefaultHandler;
	}

	pDriverObject->MajorFunction[IRP_MJ_CREATE] = CreateCloseHandler;
	pDriverObject->MajorFunction[IRP_MJ_CLOSE] = CreateCloseHandler;
	pDriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = DeviceIOControlHandler;

	pDriverObject->DriverUnload = DriverUnload;

	RtlInitUnicodeString(&uniDeviceName, L"\\Device\\KernelExploitDriver");
	RtlInitUnicodeString(&uniDosDeviceName, L"\\DosDevices\\KernelExploitDriver");

	status = IoCreateDevice(
		pDriverObject,
		0,
		&uniDeviceName,
		FILE_DEVICE_UNKNOWN,
		FILE_DEVICE_SECURE_OPEN,
		FALSE,
		&pDeviceObject
		);

	if (!NT_SUCCESS(status))
	{
		goto _RET;
	}

	//pDeviceObject->Flags |= DO_BUFFERED_IO;
	pDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

	status = IoCreateSymbolicLink(&uniDosDeviceName, &uniDeviceName);

	if (!NT_SUCCESS(status))
	{
		goto _RET;
	}

	return status;

_RET:
	IoDeleteSymbolicLink(&uniDosDeviceName);
	IoDeleteDevice(pDriverObject->DeviceObject);

	return status;
}